<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

    <script type="text/javascript">
    var REQUIRED_SUBTASKS = {};

    /** <%#
     * Logs sufficient time spent waiting for the task to load, hides instructions
     * and asks rater to release the task. %>
     */
    function askRaterToQuit() {
      logSufficientApiWaitTime();
      logError();
      document.getElementById('instructions').style.display = 'none';
      document.getElementById('wait-message').style.display = 'none';
      document.getElementById('error-message').style.display = 'inline';
    }

    /** <%#
     * Parses YouTube Data API response, displays a table of rating subtasks, marks
     * the subtasks as required for task submission, and logs sufficient amount of
     * time spent waiting on the API.  The youtubeIds parameter lists the videos
     * in the order in which questions should be asked, and apiResponse contains
     * data about the videos with those IDs.
     * @param {Object} apiResponse A response from the Google Javascript API;
     *        expected to have a 'result' object. Details:
              developers.google.com/api-client-library/javascript/features/promises
     * @param {Array<string>} youtubeIds Array of 11-character "external" video IDs.
     * %>
     */
    function renderSubtasks(apiResponse, youtubeIds) {
      document.getElementById('wait-message').style.display = 'none';
      document.getElementById('task-table').style.display = 'table';
      var videoData = parseVideoMetadata(apiResponse);
      var raterVideoIdx = 1;
      for (var subtaskIdx = 1; subtaskIdx <= youtubeIds.length; ++subtaskIdx) {
        var data = videoData[youtubeIds[subtaskIdx - 1]];
        if (!data) {
          // <%# There was no data for this video, or data was incomplete; so do not
          // ask the rater to rate it. %>
          continue;
        }
        var l = lockup(data.thumbnailUrl, data.title,
                       data.channelTitle, data.duration);
        markAsRequired(subtaskIdx, raterVideoIdx);
        renderOneSubtask(subtaskIdx, raterVideoIdx, l);
        raterVideoIdx++;
      }
      logSufficientApiWaitTime();
    }

    /** <%#
     * Causes the taskIdx-th rating subtask to appear. The task is a row in a table;
     * the row should already exist in the document, but be hidden.  This function
     * puts the given lockup in the row, instantiates a slider in the row, and gives
     * the row a rater-visible number.
     * @param {number} taskIdx Which subtask (i.e. table row) to populate.  Should
                       be between 1 and 20.
     * @param {number} raterVideoNumber Number to write in this row for rater
     *                 reference (e.g. telling rater "please rate video X").
     * @param {HTMLElement} lockup showing YouTube video title, thumbnail, uploader.
     * %>
     */
    function renderOneSubtask(taskIdx, raterVideoNumber, lockup) {
      var subtaskId = 'subtask-' + taskIdx;
      document.getElementById(subtaskId).style.display = '';

      var videoNumberId = 'video-number-' + taskIdx;
      document.getElementById(videoNumberId).innerText = '' + raterVideoNumber;

      var videoLockupId = 'video-lockup-' + taskIdx;
      document.getElementById(videoLockupId).appendChild(lockup);

      renderSlider(taskIdx);
    }

    /** <%#
     * Causes the taskIdx-th rating subtask to appear. The task is a row in a table;
     * the row should already exist in the document, but be hidden.  This function
     * puts the given lockup in the row, instantiates a slider in the row, and gives
     * the row a rater-visible number.
     * @param {number} taskIdx Which subtask (i.e. table row) to populate.  Should
                       be between 1 and 20.
     * @param {number} raterVideoNumber Number to write in this row for rater
     *                 reference (e.g. telling rater "please rate video X").
     * @param {HTMLElement} lockup showing YouTube video title, thumbnail, uploader.
     * %>
     */
    function renderOneSubtask(taskIdx, raterVideoNumber, lockup) {
      var subtaskId = 'subtask-' + taskIdx;
      document.getElementById(subtaskId).style.display = '';

      var videoNumberId = 'video-number-' + taskIdx;
      document.getElementById(videoNumberId).innerText = '' + raterVideoNumber;

      var videoLockupId = 'video-lockup-' + taskIdx;
      document.getElementById(videoLockupId).appendChild(lockup);

      renderSlider(taskIdx);
    }

    /** <%#
     * Instantiates the slider for the given subtask.  Depends on page HTML.
     * @param {number} taskIdx The index of the subtask for which slider will be
     *                 instantiated. %>
     */
    function renderSlider(taskIdx) {
      var inputName = 'trashiness.video.' + taskIdx;
      var sliderId = 'slider-' + taskIdx;
      var s = new evl.component.Slider2({
        "color": "green",
        "minimum": 0,
        "maximum": 4,
        "tickLabelList": ["N/A", "Few/Zero", "Some", "Many", "Most"],
        "startSmallTicksIndex": 1,
        "showSmallTicks": true,
        "showTinyTicks": false,
        }, inputName);
      s.render(goog.dom.getElement(sliderId));
    }

    /** <%#
     * Associates taskIdx and raterVideoIdx in a global object.  Used by task
     * validation: when asking rater to "please provide rating for video number 5",
     * for example, the 5th video we show the rater might not be the fifth video for
     * which we wanted ratings -- we might have skipped a few videos if data API did
     * not return title and uploader for them (might happen if video is taken down).
     * @param {number} taskIdx Index of a video rating subtask (in range 0-49).
     * @param {number} raterVideoIdx Index of the subtask as shown to rater. %>
     */
    function markAsRequired(taskIdx, raterVideoIdx) {
      REQUIRED_SUBTASKS[taskIdx] = raterVideoIdx;
      document.getElementById('required-subtasks').value = JSON.stringify(
          REQUIRED_SUBTASKS);
    }

    /** <%#
     * Logs in hidden input the fact that the rater waited a sufficient amount of
     * time for the task to load before trying to submit. %>
     */
    function logSufficientApiWaitTime() {
      document.getElementById('api-wait-log').value = 'true';
    }

    /** <%#
     * Logs in hidden input the fact that the task did not load correctly. %>
     */
    function logError() {
      document.getElementById('error-log').value = 'true';
    }


    var API_WAIT_MILLIS = 20000;
    var API_SUCCESS = 'api_success';
    var API_TIMEOUT = 'api_timeout';
    function dispatch(branch) {
      return function(argument) {
        return {'branch': branch, 'argument': argument};
      }
    }

    /** <%#
     * Fetches YouTube video metadata and renders the task. If there's an error or
     * 10 seconds elapse before API returns with data, instead asks the rater to
     * release the task. %>
     */
    function init() {
      gapi.client.setApiKey(KEY);
      setTimeout(logSufficientApiWaitTime, API_WAIT_MILLIS);
      Promise.race([
        gapi.client.load('youtube', 'v3').then(
          function() {
            return requestVideoMetadata(<%= JSON.stringify(YoutubeIds(item)) %>);
          }).then(dispatch(API_SUCCESS)),
        waitMillis(API_WAIT_MILLIS).then(dispatch(API_TIMEOUT))])
      .then(
        // <%# "dispatch" is called twice, but Promise.race ensures that this
        // anonymous function runs only for the first branch to complete the
        // race. %>
        function(x) {
          switch (x.branch) {
            case API_SUCCESS:
              renderSubtasks(x.argument, <%= JSON.stringify(YoutubeIds(item)) %>);
              break;
            case API_TIMEOUT:
              askRaterToQuit();
              break;
            default:
              askRaterToQuit();
          }
       }).catch(askRaterToQuit);
    }

    </script>
  </body>
</html>
